// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_
#define FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace NymaTypes {

struct EnumValue;
struct EnumValueBuilder;
struct EnumValueT;

struct Setting;
struct SettingBuilder;
struct SettingT;

struct Settings;
struct SettingsBuilder;
struct SettingsT;

struct NButtonInfo;
struct NButtonInfoBuilder;
struct NButtonInfoT;

struct NAxisInfo;
struct NAxisInfoBuilder;
struct NAxisInfoT;

struct NSwitchInfo;
struct NSwitchInfoBuilder;
struct NSwitchInfoT;

struct NSwitchPosition;
struct NSwitchPositionBuilder;
struct NSwitchPositionT;

struct NStatusInfo;
struct NStatusInfoBuilder;
struct NStatusInfoT;

struct NStatusState;
struct NStatusStateBuilder;
struct NStatusStateT;

struct NInputInfo;
struct NInputInfoBuilder;
struct NInputInfoT;

struct NDeviceInfo;
struct NDeviceInfoBuilder;
struct NDeviceInfoT;

struct NPortInfo;
struct NPortInfoBuilder;
struct NPortInfoT;

struct NPorts;
struct NPortsBuilder;
struct NPortsT;

enum SettingType : int32_t {
  /// (signed), int8, int16, int32, int64(saved as)
  SettingType_Int = 0,
  /// uint8, uint16, uint32, uint64(saved as)
  SettingType_Uint = 1,
  /// 0 or 1
  SettingType_Bool = 2,
  /// float64
  SettingType_Float = 3,
  SettingType_String = 4,
  /// string value from a list of potential strings
  SettingType_Enum = 5,
  /// TODO: How do these work
  SettingType_MultiEnum = 6,
  /// Shouldn't see any of these
  SettingType_Alias = 7,
  SettingType_MIN = SettingType_Int,
  SettingType_MAX = SettingType_Alias
};

inline const SettingType (&EnumValuesSettingType())[8] {
  static const SettingType values[] = {
    SettingType_Int,
    SettingType_Uint,
    SettingType_Bool,
    SettingType_Float,
    SettingType_String,
    SettingType_Enum,
    SettingType_MultiEnum,
    SettingType_Alias
  };
  return values;
}

inline const char * const *EnumNamesSettingType() {
  static const char * const names[9] = {
    "Int",
    "Uint",
    "Bool",
    "Float",
    "String",
    "Enum",
    "MultiEnum",
    "Alias",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettingType(SettingType e) {
  if (::flatbuffers::IsOutRange(e, SettingType_Int, SettingType_Alias)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettingType()[index];
}

enum SettingsFlags : uint32_t {
  /// TODO(cats)
  SettingsFlags_Input = 1,
  SettingsFlags_Sound = 2,
  SettingsFlags_Video = 4,
  /// User-configurable physical->virtual button/axes and hotkey mappings(driver-side code category mainly).
  SettingsFlags_InputMapping = 8,
  SettingsFlags_Path = 16,
  /// If the setting affects emulation from the point of view of the emulated program
  SettingsFlags_EmuState = 256,
  /// If it's safe for an untrusted source to modify it, probably only used in conjunction with MDFNST_EX_EMU_STATE and network play
  SettingsFlags_UntrustedSafe = 512,
  /// Suppress documentation generation for this setting.
  SettingsFlags_SuppressDoc = 1024,
  /// Auto-generated common template setting(like nes.xscale, pce.xscale, vb.xscale, nes.enable, pce.enable, vb.enable)
  SettingsFlags_CommonTemplate = 2048,
  /// Don't save setting in settings file.
  SettingsFlags_NonPersistent = 4096,
  /// TODO(in progress)
  SettingsFlags_RequiresReload = 16384,
  SettingsFlags_RequiresRestart = 32768,
  SettingsFlags_NONE = 0,
  SettingsFlags_ANY = 57119
};

inline const SettingsFlags (&EnumValuesSettingsFlags())[12] {
  static const SettingsFlags values[] = {
    SettingsFlags_Input,
    SettingsFlags_Sound,
    SettingsFlags_Video,
    SettingsFlags_InputMapping,
    SettingsFlags_Path,
    SettingsFlags_EmuState,
    SettingsFlags_UntrustedSafe,
    SettingsFlags_SuppressDoc,
    SettingsFlags_CommonTemplate,
    SettingsFlags_NonPersistent,
    SettingsFlags_RequiresReload,
    SettingsFlags_RequiresRestart
  };
  return values;
}

inline const char *EnumNameSettingsFlags(SettingsFlags e) {
  switch (e) {
    case SettingsFlags_Input: return "Input";
    case SettingsFlags_Sound: return "Sound";
    case SettingsFlags_Video: return "Video";
    case SettingsFlags_InputMapping: return "InputMapping";
    case SettingsFlags_Path: return "Path";
    case SettingsFlags_EmuState: return "EmuState";
    case SettingsFlags_UntrustedSafe: return "UntrustedSafe";
    case SettingsFlags_SuppressDoc: return "SuppressDoc";
    case SettingsFlags_CommonTemplate: return "CommonTemplate";
    case SettingsFlags_NonPersistent: return "NonPersistent";
    case SettingsFlags_RequiresReload: return "RequiresReload";
    case SettingsFlags_RequiresRestart: return "RequiresRestart";
    default: return "";
  }
}

enum InputType : uint8_t {
  InputType_Padding0 = 0,
  InputType_Padding1 = 1,
  InputType_Button = 2,
  InputType_ButtonCanRapid = 3,
  InputType_Switch = 4,
  InputType_Status = 5,
  InputType_Axis = 6,
  InputType_PointerX = 7,
  InputType_PointerY = 8,
  InputType_AxisRel = 9,
  InputType_ByteSpecial = 10,
  InputType_ResetButton = 11,
  InputType_ButtonAnalog = 12,
  InputType_Rumble = 13,
  InputType_MIN = InputType_Padding0,
  InputType_MAX = InputType_Rumble
};

inline const InputType (&EnumValuesInputType())[14] {
  static const InputType values[] = {
    InputType_Padding0,
    InputType_Padding1,
    InputType_Button,
    InputType_ButtonCanRapid,
    InputType_Switch,
    InputType_Status,
    InputType_Axis,
    InputType_PointerX,
    InputType_PointerY,
    InputType_AxisRel,
    InputType_ByteSpecial,
    InputType_ResetButton,
    InputType_ButtonAnalog,
    InputType_Rumble
  };
  return values;
}

inline const char * const *EnumNamesInputType() {
  static const char * const names[15] = {
    "Padding0",
    "Padding1",
    "Button",
    "ButtonCanRapid",
    "Switch",
    "Status",
    "Axis",
    "PointerX",
    "PointerY",
    "AxisRel",
    "ByteSpecial",
    "ResetButton",
    "ButtonAnalog",
    "Rumble",
    nullptr
  };
  return names;
}

inline const char *EnumNameInputType(InputType e) {
  if (::flatbuffers::IsOutRange(e, InputType_Padding0, InputType_Rumble)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInputType()[index];
}

enum AxisFlags : uint8_t {
  AxisFlags_Sqlr = 1,
  AxisFlags_InvertCo = 2,
  AxisFlags_SettingsUndoc = 128,
  AxisFlags_NONE = 0,
  AxisFlags_ANY = 131
};

inline const AxisFlags (&EnumValuesAxisFlags())[3] {
  static const AxisFlags values[] = {
    AxisFlags_Sqlr,
    AxisFlags_InvertCo,
    AxisFlags_SettingsUndoc
  };
  return values;
}

inline const char *EnumNameAxisFlags(AxisFlags e) {
  switch (e) {
    case AxisFlags_Sqlr: return "Sqlr";
    case AxisFlags_InvertCo: return "InvertCo";
    case AxisFlags_SettingsUndoc: return "SettingsUndoc";
    default: return "";
  }
}

enum DeviceFlags : uint8_t {
  DeviceFlags_Keyboard = 1,
  DeviceFlags_Unique = 2,
  DeviceFlags_NONE = 0,
  DeviceFlags_ANY = 3
};

inline const DeviceFlags (&EnumValuesDeviceFlags())[2] {
  static const DeviceFlags values[] = {
    DeviceFlags_Keyboard,
    DeviceFlags_Unique
  };
  return values;
}

inline const char * const *EnumNamesDeviceFlags() {
  static const char * const names[3] = {
    "Keyboard",
    "Unique",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceFlags(DeviceFlags e) {
  if (::flatbuffers::IsOutRange(e, DeviceFlags_Keyboard, DeviceFlags_Unique)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(DeviceFlags_Keyboard);
  return EnumNamesDeviceFlags()[index];
}

enum PortFlags : uint8_t {
  PortFlags_NoUserSelect = 1,
  PortFlags_NONE = 0,
  PortFlags_ANY = 1
};

inline const PortFlags (&EnumValuesPortFlags())[1] {
  static const PortFlags values[] = {
    PortFlags_NoUserSelect
  };
  return values;
}

inline const char * const *EnumNamesPortFlags() {
  static const char * const names[2] = {
    "NoUserSelect",
    nullptr
  };
  return names;
}

inline const char *EnumNamePortFlags(PortFlags e) {
  if (::flatbuffers::IsOutRange(e, PortFlags_NoUserSelect, PortFlags_NoUserSelect)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PortFlags_NoUserSelect);
  return EnumNamesPortFlags()[index];
}

enum NInputExtra : uint8_t {
  NInputExtra_NONE = 0,
  NInputExtra_Button = 1,
  NInputExtra_Axis = 2,
  NInputExtra_Switch = 3,
  NInputExtra_Status = 4,
  NInputExtra_MIN = NInputExtra_NONE,
  NInputExtra_MAX = NInputExtra_Status
};

inline const NInputExtra (&EnumValuesNInputExtra())[5] {
  static const NInputExtra values[] = {
    NInputExtra_NONE,
    NInputExtra_Button,
    NInputExtra_Axis,
    NInputExtra_Switch,
    NInputExtra_Status
  };
  return values;
}

inline const char * const *EnumNamesNInputExtra() {
  static const char * const names[6] = {
    "NONE",
    "Button",
    "Axis",
    "Switch",
    "Status",
    nullptr
  };
  return names;
}

inline const char *EnumNameNInputExtra(NInputExtra e) {
  if (::flatbuffers::IsOutRange(e, NInputExtra_NONE, NInputExtra_Status)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNInputExtra()[index];
}

template<typename T> struct NInputExtraTraits {
  static const NInputExtra enum_value = NInputExtra_NONE;
};

template<> struct NInputExtraTraits<NymaTypes::NButtonInfo> {
  static const NInputExtra enum_value = NInputExtra_Button;
};

template<> struct NInputExtraTraits<NymaTypes::NAxisInfo> {
  static const NInputExtra enum_value = NInputExtra_Axis;
};

template<> struct NInputExtraTraits<NymaTypes::NSwitchInfo> {
  static const NInputExtra enum_value = NInputExtra_Switch;
};

template<> struct NInputExtraTraits<NymaTypes::NStatusInfo> {
  static const NInputExtra enum_value = NInputExtra_Status;
};

template<typename T> struct NInputExtraUnionTraits {
  static const NInputExtra enum_value = NInputExtra_NONE;
};

template<> struct NInputExtraUnionTraits<NymaTypes::NButtonInfoT> {
  static const NInputExtra enum_value = NInputExtra_Button;
};

template<> struct NInputExtraUnionTraits<NymaTypes::NAxisInfoT> {
  static const NInputExtra enum_value = NInputExtra_Axis;
};

template<> struct NInputExtraUnionTraits<NymaTypes::NSwitchInfoT> {
  static const NInputExtra enum_value = NInputExtra_Switch;
};

template<> struct NInputExtraUnionTraits<NymaTypes::NStatusInfoT> {
  static const NInputExtra enum_value = NInputExtra_Status;
};

struct NInputExtraUnion {
  NInputExtra type;
  void *value;

  NInputExtraUnion() : type(NInputExtra_NONE), value(nullptr) {}
  NInputExtraUnion(NInputExtraUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(NInputExtra_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  NInputExtraUnion(const NInputExtraUnion &);
  NInputExtraUnion &operator=(const NInputExtraUnion &u)
    { NInputExtraUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  NInputExtraUnion &operator=(NInputExtraUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~NInputExtraUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = NInputExtraUnionTraits<RT>::enum_value;
    if (type != NInputExtra_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, NInputExtra type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  NymaTypes::NButtonInfoT *AsButton() {
    return type == NInputExtra_Button ?
      reinterpret_cast<NymaTypes::NButtonInfoT *>(value) : nullptr;
  }
  const NymaTypes::NButtonInfoT *AsButton() const {
    return type == NInputExtra_Button ?
      reinterpret_cast<const NymaTypes::NButtonInfoT *>(value) : nullptr;
  }
  NymaTypes::NAxisInfoT *AsAxis() {
    return type == NInputExtra_Axis ?
      reinterpret_cast<NymaTypes::NAxisInfoT *>(value) : nullptr;
  }
  const NymaTypes::NAxisInfoT *AsAxis() const {
    return type == NInputExtra_Axis ?
      reinterpret_cast<const NymaTypes::NAxisInfoT *>(value) : nullptr;
  }
  NymaTypes::NSwitchInfoT *AsSwitch() {
    return type == NInputExtra_Switch ?
      reinterpret_cast<NymaTypes::NSwitchInfoT *>(value) : nullptr;
  }
  const NymaTypes::NSwitchInfoT *AsSwitch() const {
    return type == NInputExtra_Switch ?
      reinterpret_cast<const NymaTypes::NSwitchInfoT *>(value) : nullptr;
  }
  NymaTypes::NStatusInfoT *AsStatus() {
    return type == NInputExtra_Status ?
      reinterpret_cast<NymaTypes::NStatusInfoT *>(value) : nullptr;
  }
  const NymaTypes::NStatusInfoT *AsStatus() const {
    return type == NInputExtra_Status ?
      reinterpret_cast<const NymaTypes::NStatusInfoT *>(value) : nullptr;
  }
};

bool VerifyNInputExtra(::flatbuffers::Verifier &verifier, const void *obj, NInputExtra type);
bool VerifyNInputExtraVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct EnumValueT : public ::flatbuffers::NativeTable {
  typedef EnumValue TableType;
  std::string Name{};
  std::string Description{};
  std::string Value{};
};

struct EnumValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumValueT NativeTableType;
  typedef EnumValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *Description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *Value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
  EnumValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnumValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EnumValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnumValueBuilder {
  typedef EnumValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(EnumValue::VT_NAME, Name);
  }
  void add_Description(::flatbuffers::Offset<::flatbuffers::String> Description) {
    fbb_.AddOffset(EnumValue::VT_DESCRIPTION, Description);
  }
  void add_Value(::flatbuffers::Offset<::flatbuffers::String> Value) {
    fbb_.AddOffset(EnumValue::VT_VALUE, Value);
  }
  explicit EnumValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumValue> CreateEnumValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Value = 0) {
  EnumValueBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Description(Description);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumValue> CreateEnumValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *Description = nullptr,
    const char *Value = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return NymaTypes::CreateEnumValue(
      _fbb,
      Name__,
      Description__,
      Value__);
}

::flatbuffers::Offset<EnumValue> CreateEnumValue(::flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingT : public ::flatbuffers::NativeTable {
  typedef Setting TableType;
  std::string Name{};
  std::string Description{};
  std::string SettingsKey{};
  std::string DefaultValue{};
  std::string Min{};
  std::string Max{};
  NymaTypes::SettingsFlags Flags = static_cast<NymaTypes::SettingsFlags>(0);
  NymaTypes::SettingType Type = NymaTypes::SettingType_Int;
  std::vector<std::unique_ptr<NymaTypes::EnumValueT>> SettingEnums{};
  SettingT() = default;
  SettingT(const SettingT &o);
  SettingT(SettingT&&) FLATBUFFERS_NOEXCEPT = default;
  SettingT &operator=(SettingT o) FLATBUFFERS_NOEXCEPT;
};

struct Setting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SettingT NativeTableType;
  typedef SettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_SETTINGSKEY = 8,
    VT_DEFAULTVALUE = 10,
    VT_MIN = 12,
    VT_MAX = 14,
    VT_FLAGS = 16,
    VT_TYPE = 18,
    VT_SETTINGENUMS = 20
  };
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *Description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *SettingsKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGSKEY);
  }
  const ::flatbuffers::String *DefaultValue() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEFAULTVALUE);
  }
  const ::flatbuffers::String *Min() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIN);
  }
  const ::flatbuffers::String *Max() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAX);
  }
  NymaTypes::SettingsFlags Flags() const {
    return static_cast<NymaTypes::SettingsFlags>(GetField<uint32_t>(VT_FLAGS, 0));
  }
  NymaTypes::SettingType Type() const {
    return static_cast<NymaTypes::SettingType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::EnumValue>> *SettingEnums() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::EnumValue>> *>(VT_SETTINGENUMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           VerifyOffset(verifier, VT_SETTINGSKEY) &&
           verifier.VerifyString(SettingsKey()) &&
           VerifyOffset(verifier, VT_DEFAULTVALUE) &&
           verifier.VerifyString(DefaultValue()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyString(Min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyString(Max()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_SETTINGENUMS) &&
           verifier.VerifyVector(SettingEnums()) &&
           verifier.VerifyVectorOfTables(SettingEnums()) &&
           verifier.EndTable();
  }
  SettingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Setting> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingBuilder {
  typedef Setting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(Setting::VT_NAME, Name);
  }
  void add_Description(::flatbuffers::Offset<::flatbuffers::String> Description) {
    fbb_.AddOffset(Setting::VT_DESCRIPTION, Description);
  }
  void add_SettingsKey(::flatbuffers::Offset<::flatbuffers::String> SettingsKey) {
    fbb_.AddOffset(Setting::VT_SETTINGSKEY, SettingsKey);
  }
  void add_DefaultValue(::flatbuffers::Offset<::flatbuffers::String> DefaultValue) {
    fbb_.AddOffset(Setting::VT_DEFAULTVALUE, DefaultValue);
  }
  void add_Min(::flatbuffers::Offset<::flatbuffers::String> Min) {
    fbb_.AddOffset(Setting::VT_MIN, Min);
  }
  void add_Max(::flatbuffers::Offset<::flatbuffers::String> Max) {
    fbb_.AddOffset(Setting::VT_MAX, Max);
  }
  void add_Flags(NymaTypes::SettingsFlags Flags) {
    fbb_.AddElement<uint32_t>(Setting::VT_FLAGS, static_cast<uint32_t>(Flags), 0);
  }
  void add_Type(NymaTypes::SettingType Type) {
    fbb_.AddElement<int32_t>(Setting::VT_TYPE, static_cast<int32_t>(Type), 0);
  }
  void add_SettingEnums(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::EnumValue>>> SettingEnums) {
    fbb_.AddOffset(Setting::VT_SETTINGENUMS, SettingEnums);
  }
  explicit SettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Setting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Setting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Setting> CreateSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SettingsKey = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DefaultValue = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Min = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Max = 0,
    NymaTypes::SettingsFlags Flags = static_cast<NymaTypes::SettingsFlags>(0),
    NymaTypes::SettingType Type = NymaTypes::SettingType_Int,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::EnumValue>>> SettingEnums = 0) {
  SettingBuilder builder_(_fbb);
  builder_.add_SettingEnums(SettingEnums);
  builder_.add_Type(Type);
  builder_.add_Flags(Flags);
  builder_.add_Max(Max);
  builder_.add_Min(Min);
  builder_.add_DefaultValue(DefaultValue);
  builder_.add_SettingsKey(SettingsKey);
  builder_.add_Description(Description);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Setting> CreateSettingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *Description = nullptr,
    const char *SettingsKey = nullptr,
    const char *DefaultValue = nullptr,
    const char *Min = nullptr,
    const char *Max = nullptr,
    NymaTypes::SettingsFlags Flags = static_cast<NymaTypes::SettingsFlags>(0),
    NymaTypes::SettingType Type = NymaTypes::SettingType_Int,
    const std::vector<::flatbuffers::Offset<NymaTypes::EnumValue>> *SettingEnums = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  auto SettingsKey__ = SettingsKey ? _fbb.CreateString(SettingsKey) : 0;
  auto DefaultValue__ = DefaultValue ? _fbb.CreateString(DefaultValue) : 0;
  auto Min__ = Min ? _fbb.CreateString(Min) : 0;
  auto Max__ = Max ? _fbb.CreateString(Max) : 0;
  auto SettingEnums__ = SettingEnums ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::EnumValue>>(*SettingEnums) : 0;
  return NymaTypes::CreateSetting(
      _fbb,
      Name__,
      Description__,
      SettingsKey__,
      DefaultValue__,
      Min__,
      Max__,
      Flags,
      Type,
      SettingEnums__);
}

::flatbuffers::Offset<Setting> CreateSetting(::flatbuffers::FlatBufferBuilder &_fbb, const SettingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingsT : public ::flatbuffers::NativeTable {
  typedef Settings TableType;
  std::vector<std::unique_ptr<NymaTypes::SettingT>> Values{};
  SettingsT() = default;
  SettingsT(const SettingsT &o);
  SettingsT(SettingsT&&) FLATBUFFERS_NOEXCEPT = default;
  SettingsT &operator=(SettingsT o) FLATBUFFERS_NOEXCEPT;
};

struct Settings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SettingsT NativeTableType;
  typedef SettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::Setting>> *Values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::Setting>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(Values()) &&
           verifier.VerifyVectorOfTables(Values()) &&
           verifier.EndTable();
  }
  SettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Settings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingsBuilder {
  typedef Settings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::Setting>>> Values) {
    fbb_.AddOffset(Settings::VT_VALUES, Values);
  }
  explicit SettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Settings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Settings> CreateSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::Setting>>> Values = 0) {
  SettingsBuilder builder_(_fbb);
  builder_.add_Values(Values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Settings> CreateSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NymaTypes::Setting>> *Values = nullptr) {
  auto Values__ = Values ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::Setting>>(*Values) : 0;
  return NymaTypes::CreateSettings(
      _fbb,
      Values__);
}

::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NButtonInfoT : public ::flatbuffers::NativeTable {
  typedef NButtonInfo TableType;
  std::string ExcludeName{};
};

struct NButtonInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NButtonInfoT NativeTableType;
  typedef NButtonInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUDENAME = 4
  };
  const ::flatbuffers::String *ExcludeName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXCLUDENAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXCLUDENAME) &&
           verifier.VerifyString(ExcludeName()) &&
           verifier.EndTable();
  }
  NButtonInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NButtonInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NButtonInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NButtonInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NButtonInfoBuilder {
  typedef NButtonInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ExcludeName(::flatbuffers::Offset<::flatbuffers::String> ExcludeName) {
    fbb_.AddOffset(NButtonInfo::VT_EXCLUDENAME, ExcludeName);
  }
  explicit NButtonInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NButtonInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NButtonInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NButtonInfo> CreateNButtonInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ExcludeName = 0) {
  NButtonInfoBuilder builder_(_fbb);
  builder_.add_ExcludeName(ExcludeName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NButtonInfo> CreateNButtonInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ExcludeName = nullptr) {
  auto ExcludeName__ = ExcludeName ? _fbb.CreateString(ExcludeName) : 0;
  return NymaTypes::CreateNButtonInfo(
      _fbb,
      ExcludeName__);
}

::flatbuffers::Offset<NButtonInfo> CreateNButtonInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NButtonInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NAxisInfoT : public ::flatbuffers::NativeTable {
  typedef NAxisInfo TableType;
  std::string SettingsNameNeg{};
  std::string SettingsNamePos{};
  std::string NameNeg{};
  std::string NamePos{};
};

struct NAxisInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NAxisInfoT NativeTableType;
  typedef NAxisInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGSNAMENEG = 4,
    VT_SETTINGSNAMEPOS = 6,
    VT_NAMENEG = 8,
    VT_NAMEPOS = 10
  };
  const ::flatbuffers::String *SettingsNameNeg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGSNAMENEG);
  }
  const ::flatbuffers::String *SettingsNamePos() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGSNAMEPOS);
  }
  const ::flatbuffers::String *NameNeg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAMENEG);
  }
  const ::flatbuffers::String *NamePos() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAMEPOS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETTINGSNAMENEG) &&
           verifier.VerifyString(SettingsNameNeg()) &&
           VerifyOffset(verifier, VT_SETTINGSNAMEPOS) &&
           verifier.VerifyString(SettingsNamePos()) &&
           VerifyOffset(verifier, VT_NAMENEG) &&
           verifier.VerifyString(NameNeg()) &&
           VerifyOffset(verifier, VT_NAMEPOS) &&
           verifier.VerifyString(NamePos()) &&
           verifier.EndTable();
  }
  NAxisInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NAxisInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NAxisInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NAxisInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NAxisInfoBuilder {
  typedef NAxisInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SettingsNameNeg(::flatbuffers::Offset<::flatbuffers::String> SettingsNameNeg) {
    fbb_.AddOffset(NAxisInfo::VT_SETTINGSNAMENEG, SettingsNameNeg);
  }
  void add_SettingsNamePos(::flatbuffers::Offset<::flatbuffers::String> SettingsNamePos) {
    fbb_.AddOffset(NAxisInfo::VT_SETTINGSNAMEPOS, SettingsNamePos);
  }
  void add_NameNeg(::flatbuffers::Offset<::flatbuffers::String> NameNeg) {
    fbb_.AddOffset(NAxisInfo::VT_NAMENEG, NameNeg);
  }
  void add_NamePos(::flatbuffers::Offset<::flatbuffers::String> NamePos) {
    fbb_.AddOffset(NAxisInfo::VT_NAMEPOS, NamePos);
  }
  explicit NAxisInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NAxisInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NAxisInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NAxisInfo> CreateNAxisInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> SettingsNameNeg = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SettingsNamePos = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NameNeg = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NamePos = 0) {
  NAxisInfoBuilder builder_(_fbb);
  builder_.add_NamePos(NamePos);
  builder_.add_NameNeg(NameNeg);
  builder_.add_SettingsNamePos(SettingsNamePos);
  builder_.add_SettingsNameNeg(SettingsNameNeg);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NAxisInfo> CreateNAxisInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *SettingsNameNeg = nullptr,
    const char *SettingsNamePos = nullptr,
    const char *NameNeg = nullptr,
    const char *NamePos = nullptr) {
  auto SettingsNameNeg__ = SettingsNameNeg ? _fbb.CreateString(SettingsNameNeg) : 0;
  auto SettingsNamePos__ = SettingsNamePos ? _fbb.CreateString(SettingsNamePos) : 0;
  auto NameNeg__ = NameNeg ? _fbb.CreateString(NameNeg) : 0;
  auto NamePos__ = NamePos ? _fbb.CreateString(NamePos) : 0;
  return NymaTypes::CreateNAxisInfo(
      _fbb,
      SettingsNameNeg__,
      SettingsNamePos__,
      NameNeg__,
      NamePos__);
}

::flatbuffers::Offset<NAxisInfo> CreateNAxisInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NAxisInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NSwitchInfoT : public ::flatbuffers::NativeTable {
  typedef NSwitchInfo TableType;
  uint32_t DefaultPosition = 0;
  std::vector<std::unique_ptr<NymaTypes::NSwitchPositionT>> Positions{};
  NSwitchInfoT() = default;
  NSwitchInfoT(const NSwitchInfoT &o);
  NSwitchInfoT(NSwitchInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  NSwitchInfoT &operator=(NSwitchInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct NSwitchInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NSwitchInfoT NativeTableType;
  typedef NSwitchInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFAULTPOSITION = 4,
    VT_POSITIONS = 6
  };
  uint32_t DefaultPosition() const {
    return GetField<uint32_t>(VT_DEFAULTPOSITION, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>> *Positions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>> *>(VT_POSITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DEFAULTPOSITION, 4) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(Positions()) &&
           verifier.VerifyVectorOfTables(Positions()) &&
           verifier.EndTable();
  }
  NSwitchInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NSwitchInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NSwitchInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NSwitchInfoBuilder {
  typedef NSwitchInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DefaultPosition(uint32_t DefaultPosition) {
    fbb_.AddElement<uint32_t>(NSwitchInfo::VT_DEFAULTPOSITION, DefaultPosition, 0);
  }
  void add_Positions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>>> Positions) {
    fbb_.AddOffset(NSwitchInfo::VT_POSITIONS, Positions);
  }
  explicit NSwitchInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NSwitchInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NSwitchInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NSwitchInfo> CreateNSwitchInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t DefaultPosition = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>>> Positions = 0) {
  NSwitchInfoBuilder builder_(_fbb);
  builder_.add_Positions(Positions);
  builder_.add_DefaultPosition(DefaultPosition);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NSwitchInfo> CreateNSwitchInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t DefaultPosition = 0,
    const std::vector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>> *Positions = nullptr) {
  auto Positions__ = Positions ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>>(*Positions) : 0;
  return NymaTypes::CreateNSwitchInfo(
      _fbb,
      DefaultPosition,
      Positions__);
}

::flatbuffers::Offset<NSwitchInfo> CreateNSwitchInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NSwitchPositionT : public ::flatbuffers::NativeTable {
  typedef NSwitchPosition TableType;
  std::string SettingName{};
  std::string Name{};
  std::string Description{};
};

struct NSwitchPosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NSwitchPositionT NativeTableType;
  typedef NSwitchPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGNAME = 4,
    VT_NAME = 6,
    VT_DESCRIPTION = 8
  };
  const ::flatbuffers::String *SettingName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGNAME);
  }
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *Description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETTINGNAME) &&
           verifier.VerifyString(SettingName()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           verifier.EndTable();
  }
  NSwitchPositionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NSwitchPositionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NSwitchPosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchPositionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NSwitchPositionBuilder {
  typedef NSwitchPosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SettingName(::flatbuffers::Offset<::flatbuffers::String> SettingName) {
    fbb_.AddOffset(NSwitchPosition::VT_SETTINGNAME, SettingName);
  }
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(NSwitchPosition::VT_NAME, Name);
  }
  void add_Description(::flatbuffers::Offset<::flatbuffers::String> Description) {
    fbb_.AddOffset(NSwitchPosition::VT_DESCRIPTION, Description);
  }
  explicit NSwitchPositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NSwitchPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NSwitchPosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NSwitchPosition> CreateNSwitchPosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> SettingName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Description = 0) {
  NSwitchPositionBuilder builder_(_fbb);
  builder_.add_Description(Description);
  builder_.add_Name(Name);
  builder_.add_SettingName(SettingName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NSwitchPosition> CreateNSwitchPositionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *SettingName = nullptr,
    const char *Name = nullptr,
    const char *Description = nullptr) {
  auto SettingName__ = SettingName ? _fbb.CreateString(SettingName) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  return NymaTypes::CreateNSwitchPosition(
      _fbb,
      SettingName__,
      Name__,
      Description__);
}

::flatbuffers::Offset<NSwitchPosition> CreateNSwitchPosition(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchPositionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NStatusInfoT : public ::flatbuffers::NativeTable {
  typedef NStatusInfo TableType;
  std::vector<std::unique_ptr<NymaTypes::NStatusStateT>> States{};
  NStatusInfoT() = default;
  NStatusInfoT(const NStatusInfoT &o);
  NStatusInfoT(NStatusInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  NStatusInfoT &operator=(NStatusInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct NStatusInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NStatusInfoT NativeTableType;
  typedef NStatusInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NStatusState>> *States() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NStatusState>> *>(VT_STATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(States()) &&
           verifier.VerifyVectorOfTables(States()) &&
           verifier.EndTable();
  }
  NStatusInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NStatusInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NStatusInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NStatusInfoBuilder {
  typedef NStatusInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_States(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NStatusState>>> States) {
    fbb_.AddOffset(NStatusInfo::VT_STATES, States);
  }
  explicit NStatusInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NStatusInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NStatusInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NStatusInfo> CreateNStatusInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NStatusState>>> States = 0) {
  NStatusInfoBuilder builder_(_fbb);
  builder_.add_States(States);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NStatusInfo> CreateNStatusInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NymaTypes::NStatusState>> *States = nullptr) {
  auto States__ = States ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NStatusState>>(*States) : 0;
  return NymaTypes::CreateNStatusInfo(
      _fbb,
      States__);
}

::flatbuffers::Offset<NStatusInfo> CreateNStatusInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NStatusStateT : public ::flatbuffers::NativeTable {
  typedef NStatusState TableType;
  std::string ShortName{};
  std::string Name{};
  int32_t Color = 0;
};

struct NStatusState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NStatusStateT NativeTableType;
  typedef NStatusStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_NAME = 6,
    VT_COLOR = 8
  };
  const ::flatbuffers::String *ShortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t Color() const {
    return GetField<int32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(ShortName()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
  NStatusStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NStatusStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NStatusState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NStatusStateBuilder {
  typedef NStatusState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ShortName(::flatbuffers::Offset<::flatbuffers::String> ShortName) {
    fbb_.AddOffset(NStatusState::VT_SHORTNAME, ShortName);
  }
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(NStatusState::VT_NAME, Name);
  }
  void add_Color(int32_t Color) {
    fbb_.AddElement<int32_t>(NStatusState::VT_COLOR, Color, 0);
  }
  explicit NStatusStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NStatusState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NStatusState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NStatusState> CreateNStatusState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ShortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    int32_t Color = 0) {
  NStatusStateBuilder builder_(_fbb);
  builder_.add_Color(Color);
  builder_.add_Name(Name);
  builder_.add_ShortName(ShortName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NStatusState> CreateNStatusStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ShortName = nullptr,
    const char *Name = nullptr,
    int32_t Color = 0) {
  auto ShortName__ = ShortName ? _fbb.CreateString(ShortName) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return NymaTypes::CreateNStatusState(
      _fbb,
      ShortName__,
      Name__,
      Color);
}

::flatbuffers::Offset<NStatusState> CreateNStatusState(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NInputInfoT : public ::flatbuffers::NativeTable {
  typedef NInputInfo TableType;
  std::string SettingName{};
  std::string Name{};
  int16_t ConfigOrder = 0;
  uint16_t BitOffset = 0;
  NymaTypes::InputType Type = NymaTypes::InputType_Padding0;
  NymaTypes::AxisFlags Flags = static_cast<NymaTypes::AxisFlags>(0);
  uint8_t BitSize = 0;
  NymaTypes::NInputExtraUnion Extra{};
};

struct NInputInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NInputInfoT NativeTableType;
  typedef NInputInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGNAME = 4,
    VT_NAME = 6,
    VT_CONFIGORDER = 8,
    VT_BITOFFSET = 10,
    VT_TYPE = 12,
    VT_FLAGS = 14,
    VT_BITSIZE = 16,
    VT_EXTRA_TYPE = 18,
    VT_EXTRA = 20
  };
  const ::flatbuffers::String *SettingName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGNAME);
  }
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int16_t ConfigOrder() const {
    return GetField<int16_t>(VT_CONFIGORDER, 0);
  }
  uint16_t BitOffset() const {
    return GetField<uint16_t>(VT_BITOFFSET, 0);
  }
  NymaTypes::InputType Type() const {
    return static_cast<NymaTypes::InputType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  NymaTypes::AxisFlags Flags() const {
    return static_cast<NymaTypes::AxisFlags>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  uint8_t BitSize() const {
    return GetField<uint8_t>(VT_BITSIZE, 0);
  }
  NymaTypes::NInputExtra Extra_type() const {
    return static_cast<NymaTypes::NInputExtra>(GetField<uint8_t>(VT_EXTRA_TYPE, 0));
  }
  const void *Extra() const {
    return GetPointer<const void *>(VT_EXTRA);
  }
  template<typename T> const T *Extra_as() const;
  const NymaTypes::NButtonInfo *Extra_as_Button() const {
    return Extra_type() == NymaTypes::NInputExtra_Button ? static_cast<const NymaTypes::NButtonInfo *>(Extra()) : nullptr;
  }
  const NymaTypes::NAxisInfo *Extra_as_Axis() const {
    return Extra_type() == NymaTypes::NInputExtra_Axis ? static_cast<const NymaTypes::NAxisInfo *>(Extra()) : nullptr;
  }
  const NymaTypes::NSwitchInfo *Extra_as_Switch() const {
    return Extra_type() == NymaTypes::NInputExtra_Switch ? static_cast<const NymaTypes::NSwitchInfo *>(Extra()) : nullptr;
  }
  const NymaTypes::NStatusInfo *Extra_as_Status() const {
    return Extra_type() == NymaTypes::NInputExtra_Status ? static_cast<const NymaTypes::NStatusInfo *>(Extra()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETTINGNAME) &&
           verifier.VerifyString(SettingName()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int16_t>(verifier, VT_CONFIGORDER, 2) &&
           VerifyField<uint16_t>(verifier, VT_BITOFFSET, 2) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BITSIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTRA_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           VerifyNInputExtra(verifier, Extra(), Extra_type()) &&
           verifier.EndTable();
  }
  NInputInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NInputInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NInputInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NInputInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const NymaTypes::NButtonInfo *NInputInfo::Extra_as<NymaTypes::NButtonInfo>() const {
  return Extra_as_Button();
}

template<> inline const NymaTypes::NAxisInfo *NInputInfo::Extra_as<NymaTypes::NAxisInfo>() const {
  return Extra_as_Axis();
}

template<> inline const NymaTypes::NSwitchInfo *NInputInfo::Extra_as<NymaTypes::NSwitchInfo>() const {
  return Extra_as_Switch();
}

template<> inline const NymaTypes::NStatusInfo *NInputInfo::Extra_as<NymaTypes::NStatusInfo>() const {
  return Extra_as_Status();
}

struct NInputInfoBuilder {
  typedef NInputInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SettingName(::flatbuffers::Offset<::flatbuffers::String> SettingName) {
    fbb_.AddOffset(NInputInfo::VT_SETTINGNAME, SettingName);
  }
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(NInputInfo::VT_NAME, Name);
  }
  void add_ConfigOrder(int16_t ConfigOrder) {
    fbb_.AddElement<int16_t>(NInputInfo::VT_CONFIGORDER, ConfigOrder, 0);
  }
  void add_BitOffset(uint16_t BitOffset) {
    fbb_.AddElement<uint16_t>(NInputInfo::VT_BITOFFSET, BitOffset, 0);
  }
  void add_Type(NymaTypes::InputType Type) {
    fbb_.AddElement<uint8_t>(NInputInfo::VT_TYPE, static_cast<uint8_t>(Type), 0);
  }
  void add_Flags(NymaTypes::AxisFlags Flags) {
    fbb_.AddElement<uint8_t>(NInputInfo::VT_FLAGS, static_cast<uint8_t>(Flags), 0);
  }
  void add_BitSize(uint8_t BitSize) {
    fbb_.AddElement<uint8_t>(NInputInfo::VT_BITSIZE, BitSize, 0);
  }
  void add_Extra_type(NymaTypes::NInputExtra Extra_type) {
    fbb_.AddElement<uint8_t>(NInputInfo::VT_EXTRA_TYPE, static_cast<uint8_t>(Extra_type), 0);
  }
  void add_Extra(::flatbuffers::Offset<void> Extra) {
    fbb_.AddOffset(NInputInfo::VT_EXTRA, Extra);
  }
  explicit NInputInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NInputInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NInputInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NInputInfo> CreateNInputInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> SettingName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    int16_t ConfigOrder = 0,
    uint16_t BitOffset = 0,
    NymaTypes::InputType Type = NymaTypes::InputType_Padding0,
    NymaTypes::AxisFlags Flags = static_cast<NymaTypes::AxisFlags>(0),
    uint8_t BitSize = 0,
    NymaTypes::NInputExtra Extra_type = NymaTypes::NInputExtra_NONE,
    ::flatbuffers::Offset<void> Extra = 0) {
  NInputInfoBuilder builder_(_fbb);
  builder_.add_Extra(Extra);
  builder_.add_Name(Name);
  builder_.add_SettingName(SettingName);
  builder_.add_BitOffset(BitOffset);
  builder_.add_ConfigOrder(ConfigOrder);
  builder_.add_Extra_type(Extra_type);
  builder_.add_BitSize(BitSize);
  builder_.add_Flags(Flags);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NInputInfo> CreateNInputInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *SettingName = nullptr,
    const char *Name = nullptr,
    int16_t ConfigOrder = 0,
    uint16_t BitOffset = 0,
    NymaTypes::InputType Type = NymaTypes::InputType_Padding0,
    NymaTypes::AxisFlags Flags = static_cast<NymaTypes::AxisFlags>(0),
    uint8_t BitSize = 0,
    NymaTypes::NInputExtra Extra_type = NymaTypes::NInputExtra_NONE,
    ::flatbuffers::Offset<void> Extra = 0) {
  auto SettingName__ = SettingName ? _fbb.CreateString(SettingName) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return NymaTypes::CreateNInputInfo(
      _fbb,
      SettingName__,
      Name__,
      ConfigOrder,
      BitOffset,
      Type,
      Flags,
      BitSize,
      Extra_type,
      Extra);
}

::flatbuffers::Offset<NInputInfo> CreateNInputInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NInputInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NDeviceInfoT : public ::flatbuffers::NativeTable {
  typedef NDeviceInfo TableType;
  std::string ShortName{};
  std::string FullName{};
  std::string Description{};
  NymaTypes::DeviceFlags Flags = static_cast<NymaTypes::DeviceFlags>(0);
  uint32_t ByteLength = 0;
  std::vector<std::unique_ptr<NymaTypes::NInputInfoT>> Inputs{};
  NDeviceInfoT() = default;
  NDeviceInfoT(const NDeviceInfoT &o);
  NDeviceInfoT(NDeviceInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  NDeviceInfoT &operator=(NDeviceInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct NDeviceInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NDeviceInfoT NativeTableType;
  typedef NDeviceInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_FULLNAME = 6,
    VT_DESCRIPTION = 8,
    VT_FLAGS = 10,
    VT_BYTELENGTH = 12,
    VT_INPUTS = 14
  };
  const ::flatbuffers::String *ShortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  const ::flatbuffers::String *FullName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FULLNAME);
  }
  const ::flatbuffers::String *Description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  NymaTypes::DeviceFlags Flags() const {
    return static_cast<NymaTypes::DeviceFlags>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  uint32_t ByteLength() const {
    return GetField<uint32_t>(VT_BYTELENGTH, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NInputInfo>> *Inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NInputInfo>> *>(VT_INPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(ShortName()) &&
           VerifyOffset(verifier, VT_FULLNAME) &&
           verifier.VerifyString(FullName()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<uint32_t>(verifier, VT_BYTELENGTH, 4) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(Inputs()) &&
           verifier.VerifyVectorOfTables(Inputs()) &&
           verifier.EndTable();
  }
  NDeviceInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NDeviceInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NDeviceInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NDeviceInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NDeviceInfoBuilder {
  typedef NDeviceInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ShortName(::flatbuffers::Offset<::flatbuffers::String> ShortName) {
    fbb_.AddOffset(NDeviceInfo::VT_SHORTNAME, ShortName);
  }
  void add_FullName(::flatbuffers::Offset<::flatbuffers::String> FullName) {
    fbb_.AddOffset(NDeviceInfo::VT_FULLNAME, FullName);
  }
  void add_Description(::flatbuffers::Offset<::flatbuffers::String> Description) {
    fbb_.AddOffset(NDeviceInfo::VT_DESCRIPTION, Description);
  }
  void add_Flags(NymaTypes::DeviceFlags Flags) {
    fbb_.AddElement<uint8_t>(NDeviceInfo::VT_FLAGS, static_cast<uint8_t>(Flags), 0);
  }
  void add_ByteLength(uint32_t ByteLength) {
    fbb_.AddElement<uint32_t>(NDeviceInfo::VT_BYTELENGTH, ByteLength, 0);
  }
  void add_Inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NInputInfo>>> Inputs) {
    fbb_.AddOffset(NDeviceInfo::VT_INPUTS, Inputs);
  }
  explicit NDeviceInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NDeviceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NDeviceInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NDeviceInfo> CreateNDeviceInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ShortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FullName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Description = 0,
    NymaTypes::DeviceFlags Flags = static_cast<NymaTypes::DeviceFlags>(0),
    uint32_t ByteLength = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NInputInfo>>> Inputs = 0) {
  NDeviceInfoBuilder builder_(_fbb);
  builder_.add_Inputs(Inputs);
  builder_.add_ByteLength(ByteLength);
  builder_.add_Description(Description);
  builder_.add_FullName(FullName);
  builder_.add_ShortName(ShortName);
  builder_.add_Flags(Flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NDeviceInfo> CreateNDeviceInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ShortName = nullptr,
    const char *FullName = nullptr,
    const char *Description = nullptr,
    NymaTypes::DeviceFlags Flags = static_cast<NymaTypes::DeviceFlags>(0),
    uint32_t ByteLength = 0,
    const std::vector<::flatbuffers::Offset<NymaTypes::NInputInfo>> *Inputs = nullptr) {
  auto ShortName__ = ShortName ? _fbb.CreateString(ShortName) : 0;
  auto FullName__ = FullName ? _fbb.CreateString(FullName) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  auto Inputs__ = Inputs ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NInputInfo>>(*Inputs) : 0;
  return NymaTypes::CreateNDeviceInfo(
      _fbb,
      ShortName__,
      FullName__,
      Description__,
      Flags,
      ByteLength,
      Inputs__);
}

::flatbuffers::Offset<NDeviceInfo> CreateNDeviceInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NDeviceInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NPortInfoT : public ::flatbuffers::NativeTable {
  typedef NPortInfo TableType;
  std::string ShortName{};
  std::string FullName{};
  std::string DefaultDeviceShortName{};
  NymaTypes::PortFlags Flags = static_cast<NymaTypes::PortFlags>(0);
  std::vector<std::unique_ptr<NymaTypes::NDeviceInfoT>> Devices{};
  NPortInfoT() = default;
  NPortInfoT(const NPortInfoT &o);
  NPortInfoT(NPortInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  NPortInfoT &operator=(NPortInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct NPortInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NPortInfoT NativeTableType;
  typedef NPortInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_FULLNAME = 6,
    VT_DEFAULTDEVICESHORTNAME = 8,
    VT_FLAGS = 10,
    VT_DEVICES = 12
  };
  const ::flatbuffers::String *ShortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  const ::flatbuffers::String *FullName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FULLNAME);
  }
  const ::flatbuffers::String *DefaultDeviceShortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEFAULTDEVICESHORTNAME);
  }
  NymaTypes::PortFlags Flags() const {
    return static_cast<NymaTypes::PortFlags>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>> *Devices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>> *>(VT_DEVICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(ShortName()) &&
           VerifyOffset(verifier, VT_FULLNAME) &&
           verifier.VerifyString(FullName()) &&
           VerifyOffset(verifier, VT_DEFAULTDEVICESHORTNAME) &&
           verifier.VerifyString(DefaultDeviceShortName()) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(Devices()) &&
           verifier.VerifyVectorOfTables(Devices()) &&
           verifier.EndTable();
  }
  NPortInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NPortInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NPortInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NPortInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NPortInfoBuilder {
  typedef NPortInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ShortName(::flatbuffers::Offset<::flatbuffers::String> ShortName) {
    fbb_.AddOffset(NPortInfo::VT_SHORTNAME, ShortName);
  }
  void add_FullName(::flatbuffers::Offset<::flatbuffers::String> FullName) {
    fbb_.AddOffset(NPortInfo::VT_FULLNAME, FullName);
  }
  void add_DefaultDeviceShortName(::flatbuffers::Offset<::flatbuffers::String> DefaultDeviceShortName) {
    fbb_.AddOffset(NPortInfo::VT_DEFAULTDEVICESHORTNAME, DefaultDeviceShortName);
  }
  void add_Flags(NymaTypes::PortFlags Flags) {
    fbb_.AddElement<uint8_t>(NPortInfo::VT_FLAGS, static_cast<uint8_t>(Flags), 0);
  }
  void add_Devices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>>> Devices) {
    fbb_.AddOffset(NPortInfo::VT_DEVICES, Devices);
  }
  explicit NPortInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NPortInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NPortInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NPortInfo> CreateNPortInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ShortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FullName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DefaultDeviceShortName = 0,
    NymaTypes::PortFlags Flags = static_cast<NymaTypes::PortFlags>(0),
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>>> Devices = 0) {
  NPortInfoBuilder builder_(_fbb);
  builder_.add_Devices(Devices);
  builder_.add_DefaultDeviceShortName(DefaultDeviceShortName);
  builder_.add_FullName(FullName);
  builder_.add_ShortName(ShortName);
  builder_.add_Flags(Flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NPortInfo> CreateNPortInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ShortName = nullptr,
    const char *FullName = nullptr,
    const char *DefaultDeviceShortName = nullptr,
    NymaTypes::PortFlags Flags = static_cast<NymaTypes::PortFlags>(0),
    const std::vector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>> *Devices = nullptr) {
  auto ShortName__ = ShortName ? _fbb.CreateString(ShortName) : 0;
  auto FullName__ = FullName ? _fbb.CreateString(FullName) : 0;
  auto DefaultDeviceShortName__ = DefaultDeviceShortName ? _fbb.CreateString(DefaultDeviceShortName) : 0;
  auto Devices__ = Devices ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>>(*Devices) : 0;
  return NymaTypes::CreateNPortInfo(
      _fbb,
      ShortName__,
      FullName__,
      DefaultDeviceShortName__,
      Flags,
      Devices__);
}

::flatbuffers::Offset<NPortInfo> CreateNPortInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NPortInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NPortsT : public ::flatbuffers::NativeTable {
  typedef NPorts TableType;
  std::vector<std::unique_ptr<NymaTypes::NPortInfoT>> Values{};
  NPortsT() = default;
  NPortsT(const NPortsT &o);
  NPortsT(NPortsT&&) FLATBUFFERS_NOEXCEPT = default;
  NPortsT &operator=(NPortsT o) FLATBUFFERS_NOEXCEPT;
};

struct NPorts FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NPortsT NativeTableType;
  typedef NPortsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NPortInfo>> *Values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NPortInfo>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(Values()) &&
           verifier.VerifyVectorOfTables(Values()) &&
           verifier.EndTable();
  }
  NPortsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NPortsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NPorts> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NPortsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NPortsBuilder {
  typedef NPorts Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NPortInfo>>> Values) {
    fbb_.AddOffset(NPorts::VT_VALUES, Values);
  }
  explicit NPortsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NPorts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NPorts>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NPorts> CreateNPorts(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NymaTypes::NPortInfo>>> Values = 0) {
  NPortsBuilder builder_(_fbb);
  builder_.add_Values(Values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NPorts> CreateNPortsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NymaTypes::NPortInfo>> *Values = nullptr) {
  auto Values__ = Values ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NPortInfo>>(*Values) : 0;
  return NymaTypes::CreateNPorts(
      _fbb,
      Values__);
}

::flatbuffers::Offset<NPorts> CreateNPorts(::flatbuffers::FlatBufferBuilder &_fbb, const NPortsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EnumValueT *EnumValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnumValueT>(new EnumValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnumValue::UnPackTo(EnumValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
  { auto _e = Value(); if (_e) _o->Value = _e->str(); }
}

inline ::flatbuffers::Offset<EnumValue> EnumValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnumValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EnumValue> CreateEnumValue(::flatbuffers::FlatBufferBuilder &_fbb, const EnumValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnumValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  auto _Value = _o->Value.empty() ? 0 : _fbb.CreateString(_o->Value);
  return NymaTypes::CreateEnumValue(
      _fbb,
      _Name,
      _Description,
      _Value);
}

inline SettingT::SettingT(const SettingT &o)
      : Name(o.Name),
        Description(o.Description),
        SettingsKey(o.SettingsKey),
        DefaultValue(o.DefaultValue),
        Min(o.Min),
        Max(o.Max),
        Flags(o.Flags),
        Type(o.Type) {
  SettingEnums.reserve(o.SettingEnums.size());
  for (const auto &SettingEnums_ : o.SettingEnums) { SettingEnums.emplace_back((SettingEnums_) ? new NymaTypes::EnumValueT(*SettingEnums_) : nullptr); }
}

inline SettingT &SettingT::operator=(SettingT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Name, o.Name);
  std::swap(Description, o.Description);
  std::swap(SettingsKey, o.SettingsKey);
  std::swap(DefaultValue, o.DefaultValue);
  std::swap(Min, o.Min);
  std::swap(Max, o.Max);
  std::swap(Flags, o.Flags);
  std::swap(Type, o.Type);
  std::swap(SettingEnums, o.SettingEnums);
  return *this;
}

inline SettingT *Setting::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SettingT>(new SettingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Setting::UnPackTo(SettingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
  { auto _e = SettingsKey(); if (_e) _o->SettingsKey = _e->str(); }
  { auto _e = DefaultValue(); if (_e) _o->DefaultValue = _e->str(); }
  { auto _e = Min(); if (_e) _o->Min = _e->str(); }
  { auto _e = Max(); if (_e) _o->Max = _e->str(); }
  { auto _e = Flags(); _o->Flags = _e; }
  { auto _e = Type(); _o->Type = _e; }
  { auto _e = SettingEnums(); if (_e) { _o->SettingEnums.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->SettingEnums[_i]) { _e->Get(_i)->UnPackTo(_o->SettingEnums[_i].get(), _resolver); } else { _o->SettingEnums[_i] = std::unique_ptr<NymaTypes::EnumValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->SettingEnums.resize(0); } }
}

inline ::flatbuffers::Offset<Setting> Setting::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetting(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Setting> CreateSetting(::flatbuffers::FlatBufferBuilder &_fbb, const SettingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SettingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  auto _SettingsKey = _o->SettingsKey.empty() ? 0 : _fbb.CreateString(_o->SettingsKey);
  auto _DefaultValue = _o->DefaultValue.empty() ? 0 : _fbb.CreateString(_o->DefaultValue);
  auto _Min = _o->Min.empty() ? 0 : _fbb.CreateString(_o->Min);
  auto _Max = _o->Max.empty() ? 0 : _fbb.CreateString(_o->Max);
  auto _Flags = _o->Flags;
  auto _Type = _o->Type;
  auto _SettingEnums = _o->SettingEnums.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::EnumValue>> (_o->SettingEnums.size(), [](size_t i, _VectorArgs *__va) { return CreateEnumValue(*__va->__fbb, __va->__o->SettingEnums[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateSetting(
      _fbb,
      _Name,
      _Description,
      _SettingsKey,
      _DefaultValue,
      _Min,
      _Max,
      _Flags,
      _Type,
      _SettingEnums);
}

inline SettingsT::SettingsT(const SettingsT &o) {
  Values.reserve(o.Values.size());
  for (const auto &Values_ : o.Values) { Values.emplace_back((Values_) ? new NymaTypes::SettingT(*Values_) : nullptr); }
}

inline SettingsT &SettingsT::operator=(SettingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Values, o.Values);
  return *this;
}

inline SettingsT *Settings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SettingsT>(new SettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Settings::UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Values(); if (_e) { _o->Values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Values[_i]) { _e->Get(_i)->UnPackTo(_o->Values[_i].get(), _resolver); } else { _o->Values[_i] = std::unique_ptr<NymaTypes::SettingT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Values.resize(0); } }
}

inline ::flatbuffers::Offset<Settings> Settings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Values = _o->Values.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::Setting>> (_o->Values.size(), [](size_t i, _VectorArgs *__va) { return CreateSetting(*__va->__fbb, __va->__o->Values[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateSettings(
      _fbb,
      _Values);
}

inline NButtonInfoT *NButtonInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NButtonInfoT>(new NButtonInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NButtonInfo::UnPackTo(NButtonInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ExcludeName(); if (_e) _o->ExcludeName = _e->str(); }
}

inline ::flatbuffers::Offset<NButtonInfo> NButtonInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NButtonInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNButtonInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NButtonInfo> CreateNButtonInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NButtonInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NButtonInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ExcludeName = _o->ExcludeName.empty() ? 0 : _fbb.CreateString(_o->ExcludeName);
  return NymaTypes::CreateNButtonInfo(
      _fbb,
      _ExcludeName);
}

inline NAxisInfoT *NAxisInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NAxisInfoT>(new NAxisInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NAxisInfo::UnPackTo(NAxisInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SettingsNameNeg(); if (_e) _o->SettingsNameNeg = _e->str(); }
  { auto _e = SettingsNamePos(); if (_e) _o->SettingsNamePos = _e->str(); }
  { auto _e = NameNeg(); if (_e) _o->NameNeg = _e->str(); }
  { auto _e = NamePos(); if (_e) _o->NamePos = _e->str(); }
}

inline ::flatbuffers::Offset<NAxisInfo> NAxisInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NAxisInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNAxisInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NAxisInfo> CreateNAxisInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NAxisInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NAxisInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SettingsNameNeg = _o->SettingsNameNeg.empty() ? 0 : _fbb.CreateString(_o->SettingsNameNeg);
  auto _SettingsNamePos = _o->SettingsNamePos.empty() ? 0 : _fbb.CreateString(_o->SettingsNamePos);
  auto _NameNeg = _o->NameNeg.empty() ? 0 : _fbb.CreateString(_o->NameNeg);
  auto _NamePos = _o->NamePos.empty() ? 0 : _fbb.CreateString(_o->NamePos);
  return NymaTypes::CreateNAxisInfo(
      _fbb,
      _SettingsNameNeg,
      _SettingsNamePos,
      _NameNeg,
      _NamePos);
}

inline NSwitchInfoT::NSwitchInfoT(const NSwitchInfoT &o)
      : DefaultPosition(o.DefaultPosition) {
  Positions.reserve(o.Positions.size());
  for (const auto &Positions_ : o.Positions) { Positions.emplace_back((Positions_) ? new NymaTypes::NSwitchPositionT(*Positions_) : nullptr); }
}

inline NSwitchInfoT &NSwitchInfoT::operator=(NSwitchInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(DefaultPosition, o.DefaultPosition);
  std::swap(Positions, o.Positions);
  return *this;
}

inline NSwitchInfoT *NSwitchInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NSwitchInfoT>(new NSwitchInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NSwitchInfo::UnPackTo(NSwitchInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = DefaultPosition(); _o->DefaultPosition = _e; }
  { auto _e = Positions(); if (_e) { _o->Positions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Positions[_i]) { _e->Get(_i)->UnPackTo(_o->Positions[_i].get(), _resolver); } else { _o->Positions[_i] = std::unique_ptr<NymaTypes::NSwitchPositionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Positions.resize(0); } }
}

inline ::flatbuffers::Offset<NSwitchInfo> NSwitchInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNSwitchInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NSwitchInfo> CreateNSwitchInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NSwitchInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _DefaultPosition = _o->DefaultPosition;
  auto _Positions = _o->Positions.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NSwitchPosition>> (_o->Positions.size(), [](size_t i, _VectorArgs *__va) { return CreateNSwitchPosition(*__va->__fbb, __va->__o->Positions[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateNSwitchInfo(
      _fbb,
      _DefaultPosition,
      _Positions);
}

inline NSwitchPositionT *NSwitchPosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NSwitchPositionT>(new NSwitchPositionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NSwitchPosition::UnPackTo(NSwitchPositionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SettingName(); if (_e) _o->SettingName = _e->str(); }
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
}

inline ::flatbuffers::Offset<NSwitchPosition> NSwitchPosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchPositionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNSwitchPosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NSwitchPosition> CreateNSwitchPosition(::flatbuffers::FlatBufferBuilder &_fbb, const NSwitchPositionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NSwitchPositionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SettingName = _o->SettingName.empty() ? 0 : _fbb.CreateString(_o->SettingName);
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  return NymaTypes::CreateNSwitchPosition(
      _fbb,
      _SettingName,
      _Name,
      _Description);
}

inline NStatusInfoT::NStatusInfoT(const NStatusInfoT &o) {
  States.reserve(o.States.size());
  for (const auto &States_ : o.States) { States.emplace_back((States_) ? new NymaTypes::NStatusStateT(*States_) : nullptr); }
}

inline NStatusInfoT &NStatusInfoT::operator=(NStatusInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(States, o.States);
  return *this;
}

inline NStatusInfoT *NStatusInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NStatusInfoT>(new NStatusInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NStatusInfo::UnPackTo(NStatusInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = States(); if (_e) { _o->States.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->States[_i]) { _e->Get(_i)->UnPackTo(_o->States[_i].get(), _resolver); } else { _o->States[_i] = std::unique_ptr<NymaTypes::NStatusStateT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->States.resize(0); } }
}

inline ::flatbuffers::Offset<NStatusInfo> NStatusInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNStatusInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NStatusInfo> CreateNStatusInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NStatusInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _States = _o->States.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NStatusState>> (_o->States.size(), [](size_t i, _VectorArgs *__va) { return CreateNStatusState(*__va->__fbb, __va->__o->States[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateNStatusInfo(
      _fbb,
      _States);
}

inline NStatusStateT *NStatusState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NStatusStateT>(new NStatusStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NStatusState::UnPackTo(NStatusStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ShortName(); if (_e) _o->ShortName = _e->str(); }
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Color(); _o->Color = _e; }
}

inline ::flatbuffers::Offset<NStatusState> NStatusState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNStatusState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NStatusState> CreateNStatusState(::flatbuffers::FlatBufferBuilder &_fbb, const NStatusStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NStatusStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ShortName = _o->ShortName.empty() ? 0 : _fbb.CreateString(_o->ShortName);
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Color = _o->Color;
  return NymaTypes::CreateNStatusState(
      _fbb,
      _ShortName,
      _Name,
      _Color);
}

inline NInputInfoT *NInputInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NInputInfoT>(new NInputInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NInputInfo::UnPackTo(NInputInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SettingName(); if (_e) _o->SettingName = _e->str(); }
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = ConfigOrder(); _o->ConfigOrder = _e; }
  { auto _e = BitOffset(); _o->BitOffset = _e; }
  { auto _e = Type(); _o->Type = _e; }
  { auto _e = Flags(); _o->Flags = _e; }
  { auto _e = BitSize(); _o->BitSize = _e; }
  { auto _e = Extra_type(); _o->Extra.type = _e; }
  { auto _e = Extra(); if (_e) _o->Extra.value = NymaTypes::NInputExtraUnion::UnPack(_e, Extra_type(), _resolver); }
}

inline ::flatbuffers::Offset<NInputInfo> NInputInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NInputInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNInputInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NInputInfo> CreateNInputInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NInputInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NInputInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SettingName = _o->SettingName.empty() ? 0 : _fbb.CreateString(_o->SettingName);
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _ConfigOrder = _o->ConfigOrder;
  auto _BitOffset = _o->BitOffset;
  auto _Type = _o->Type;
  auto _Flags = _o->Flags;
  auto _BitSize = _o->BitSize;
  auto _Extra_type = _o->Extra.type;
  auto _Extra = _o->Extra.Pack(_fbb);
  return NymaTypes::CreateNInputInfo(
      _fbb,
      _SettingName,
      _Name,
      _ConfigOrder,
      _BitOffset,
      _Type,
      _Flags,
      _BitSize,
      _Extra_type,
      _Extra);
}

inline NDeviceInfoT::NDeviceInfoT(const NDeviceInfoT &o)
      : ShortName(o.ShortName),
        FullName(o.FullName),
        Description(o.Description),
        Flags(o.Flags),
        ByteLength(o.ByteLength) {
  Inputs.reserve(o.Inputs.size());
  for (const auto &Inputs_ : o.Inputs) { Inputs.emplace_back((Inputs_) ? new NymaTypes::NInputInfoT(*Inputs_) : nullptr); }
}

inline NDeviceInfoT &NDeviceInfoT::operator=(NDeviceInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(ShortName, o.ShortName);
  std::swap(FullName, o.FullName);
  std::swap(Description, o.Description);
  std::swap(Flags, o.Flags);
  std::swap(ByteLength, o.ByteLength);
  std::swap(Inputs, o.Inputs);
  return *this;
}

inline NDeviceInfoT *NDeviceInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NDeviceInfoT>(new NDeviceInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NDeviceInfo::UnPackTo(NDeviceInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ShortName(); if (_e) _o->ShortName = _e->str(); }
  { auto _e = FullName(); if (_e) _o->FullName = _e->str(); }
  { auto _e = Description(); if (_e) _o->Description = _e->str(); }
  { auto _e = Flags(); _o->Flags = _e; }
  { auto _e = ByteLength(); _o->ByteLength = _e; }
  { auto _e = Inputs(); if (_e) { _o->Inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Inputs[_i]) { _e->Get(_i)->UnPackTo(_o->Inputs[_i].get(), _resolver); } else { _o->Inputs[_i] = std::unique_ptr<NymaTypes::NInputInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Inputs.resize(0); } }
}

inline ::flatbuffers::Offset<NDeviceInfo> NDeviceInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NDeviceInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNDeviceInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NDeviceInfo> CreateNDeviceInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NDeviceInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NDeviceInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ShortName = _o->ShortName.empty() ? 0 : _fbb.CreateString(_o->ShortName);
  auto _FullName = _o->FullName.empty() ? 0 : _fbb.CreateString(_o->FullName);
  auto _Description = _o->Description.empty() ? 0 : _fbb.CreateString(_o->Description);
  auto _Flags = _o->Flags;
  auto _ByteLength = _o->ByteLength;
  auto _Inputs = _o->Inputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NInputInfo>> (_o->Inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateNInputInfo(*__va->__fbb, __va->__o->Inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateNDeviceInfo(
      _fbb,
      _ShortName,
      _FullName,
      _Description,
      _Flags,
      _ByteLength,
      _Inputs);
}

inline NPortInfoT::NPortInfoT(const NPortInfoT &o)
      : ShortName(o.ShortName),
        FullName(o.FullName),
        DefaultDeviceShortName(o.DefaultDeviceShortName),
        Flags(o.Flags) {
  Devices.reserve(o.Devices.size());
  for (const auto &Devices_ : o.Devices) { Devices.emplace_back((Devices_) ? new NymaTypes::NDeviceInfoT(*Devices_) : nullptr); }
}

inline NPortInfoT &NPortInfoT::operator=(NPortInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(ShortName, o.ShortName);
  std::swap(FullName, o.FullName);
  std::swap(DefaultDeviceShortName, o.DefaultDeviceShortName);
  std::swap(Flags, o.Flags);
  std::swap(Devices, o.Devices);
  return *this;
}

inline NPortInfoT *NPortInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NPortInfoT>(new NPortInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NPortInfo::UnPackTo(NPortInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ShortName(); if (_e) _o->ShortName = _e->str(); }
  { auto _e = FullName(); if (_e) _o->FullName = _e->str(); }
  { auto _e = DefaultDeviceShortName(); if (_e) _o->DefaultDeviceShortName = _e->str(); }
  { auto _e = Flags(); _o->Flags = _e; }
  { auto _e = Devices(); if (_e) { _o->Devices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Devices[_i]) { _e->Get(_i)->UnPackTo(_o->Devices[_i].get(), _resolver); } else { _o->Devices[_i] = std::unique_ptr<NymaTypes::NDeviceInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Devices.resize(0); } }
}

inline ::flatbuffers::Offset<NPortInfo> NPortInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NPortInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNPortInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NPortInfo> CreateNPortInfo(::flatbuffers::FlatBufferBuilder &_fbb, const NPortInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NPortInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ShortName = _o->ShortName.empty() ? 0 : _fbb.CreateString(_o->ShortName);
  auto _FullName = _o->FullName.empty() ? 0 : _fbb.CreateString(_o->FullName);
  auto _DefaultDeviceShortName = _o->DefaultDeviceShortName.empty() ? 0 : _fbb.CreateString(_o->DefaultDeviceShortName);
  auto _Flags = _o->Flags;
  auto _Devices = _o->Devices.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NDeviceInfo>> (_o->Devices.size(), [](size_t i, _VectorArgs *__va) { return CreateNDeviceInfo(*__va->__fbb, __va->__o->Devices[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateNPortInfo(
      _fbb,
      _ShortName,
      _FullName,
      _DefaultDeviceShortName,
      _Flags,
      _Devices);
}

inline NPortsT::NPortsT(const NPortsT &o) {
  Values.reserve(o.Values.size());
  for (const auto &Values_ : o.Values) { Values.emplace_back((Values_) ? new NymaTypes::NPortInfoT(*Values_) : nullptr); }
}

inline NPortsT &NPortsT::operator=(NPortsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Values, o.Values);
  return *this;
}

inline NPortsT *NPorts::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NPortsT>(new NPortsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NPorts::UnPackTo(NPortsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Values(); if (_e) { _o->Values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Values[_i]) { _e->Get(_i)->UnPackTo(_o->Values[_i].get(), _resolver); } else { _o->Values[_i] = std::unique_ptr<NymaTypes::NPortInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Values.resize(0); } }
}

inline ::flatbuffers::Offset<NPorts> NPorts::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NPortsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNPorts(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NPorts> CreateNPorts(::flatbuffers::FlatBufferBuilder &_fbb, const NPortsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NPortsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Values = _o->Values.size() ? _fbb.CreateVector<::flatbuffers::Offset<NymaTypes::NPortInfo>> (_o->Values.size(), [](size_t i, _VectorArgs *__va) { return CreateNPortInfo(*__va->__fbb, __va->__o->Values[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NymaTypes::CreateNPorts(
      _fbb,
      _Values);
}

inline bool VerifyNInputExtra(::flatbuffers::Verifier &verifier, const void *obj, NInputExtra type) {
  switch (type) {
    case NInputExtra_NONE: {
      return true;
    }
    case NInputExtra_Button: {
      auto ptr = reinterpret_cast<const NymaTypes::NButtonInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NInputExtra_Axis: {
      auto ptr = reinterpret_cast<const NymaTypes::NAxisInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NInputExtra_Switch: {
      auto ptr = reinterpret_cast<const NymaTypes::NSwitchInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NInputExtra_Status: {
      auto ptr = reinterpret_cast<const NymaTypes::NStatusInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNInputExtraVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNInputExtra(
        verifier,  values->Get(i), types->GetEnum<NInputExtra>(i))) {
      return false;
    }
  }
  return true;
}

inline void *NInputExtraUnion::UnPack(const void *obj, NInputExtra type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case NInputExtra_Button: {
      auto ptr = reinterpret_cast<const NymaTypes::NButtonInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case NInputExtra_Axis: {
      auto ptr = reinterpret_cast<const NymaTypes::NAxisInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case NInputExtra_Switch: {
      auto ptr = reinterpret_cast<const NymaTypes::NSwitchInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case NInputExtra_Status: {
      auto ptr = reinterpret_cast<const NymaTypes::NStatusInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> NInputExtraUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case NInputExtra_Button: {
      auto ptr = reinterpret_cast<const NymaTypes::NButtonInfoT *>(value);
      return CreateNButtonInfo(_fbb, ptr, _rehasher).Union();
    }
    case NInputExtra_Axis: {
      auto ptr = reinterpret_cast<const NymaTypes::NAxisInfoT *>(value);
      return CreateNAxisInfo(_fbb, ptr, _rehasher).Union();
    }
    case NInputExtra_Switch: {
      auto ptr = reinterpret_cast<const NymaTypes::NSwitchInfoT *>(value);
      return CreateNSwitchInfo(_fbb, ptr, _rehasher).Union();
    }
    case NInputExtra_Status: {
      auto ptr = reinterpret_cast<const NymaTypes::NStatusInfoT *>(value);
      return CreateNStatusInfo(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline NInputExtraUnion::NInputExtraUnion(const NInputExtraUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case NInputExtra_Button: {
      value = new NymaTypes::NButtonInfoT(*reinterpret_cast<NymaTypes::NButtonInfoT *>(u.value));
      break;
    }
    case NInputExtra_Axis: {
      value = new NymaTypes::NAxisInfoT(*reinterpret_cast<NymaTypes::NAxisInfoT *>(u.value));
      break;
    }
    case NInputExtra_Switch: {
      value = new NymaTypes::NSwitchInfoT(*reinterpret_cast<NymaTypes::NSwitchInfoT *>(u.value));
      break;
    }
    case NInputExtra_Status: {
      value = new NymaTypes::NStatusInfoT(*reinterpret_cast<NymaTypes::NStatusInfoT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void NInputExtraUnion::Reset() {
  switch (type) {
    case NInputExtra_Button: {
      auto ptr = reinterpret_cast<NymaTypes::NButtonInfoT *>(value);
      delete ptr;
      break;
    }
    case NInputExtra_Axis: {
      auto ptr = reinterpret_cast<NymaTypes::NAxisInfoT *>(value);
      delete ptr;
      break;
    }
    case NInputExtra_Switch: {
      auto ptr = reinterpret_cast<NymaTypes::NSwitchInfoT *>(value);
      delete ptr;
      break;
    }
    case NInputExtra_Status: {
      auto ptr = reinterpret_cast<NymaTypes::NStatusInfoT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = NInputExtra_NONE;
}

}  // namespace NymaTypes

#endif  // FLATBUFFERS_GENERATED_NYMATYPES_NYMATYPES_H_
